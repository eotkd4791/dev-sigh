### [BOJ17298] 오큰수

![](./images/boj.png)

### 문제 링크

[BOJ17298 - 오큰수](https://www.acmicpc.net/problem/17298)

### 문제 설명

N개의 원소로 이루어진 수열이 주어진다.

수열의 각 원소를 기준으로 오른쪽에 있는 원소 중에 기준이 되는 원소보다 큰 수가 있다면 그 수를, 없다면 -1을 출력한다.

수열을 이루는 원소의 갯수를 의미하는 N은 최대 `백만`(10<sup>6</sup>), 원소의 크기의 범위는 1에서 `백만`이다.

### 풀이 설명

수열의 각 요소보다 `큰`, `오른쪽에 있는`, `가장 가까운` 수를 차례대로 구하는 문제였다.
N이 최대 백만인 경우에 N<sup>2</sup>만큼의 연산을 하는 완전탐색으로는 `시간 초과`가 발생한다.

> 기준 원소에서 오른쪽으로 가장 가까운 원소를 구해야 하므로 삽입되는 순서가 유지되어야하고,
> 기준 원소보다 큰 원소가 바로 오른쪽에 없을 때, 이후에도 나올 수 있기 때문에
> 크기 비교 연산을 나중으로 미룰 수 있도록 여러 데이터를 가지고 있을 수 있고,
> 삽입, 삭제 연산이 최대 N번 이루어질 수 있기 때문에 성능이 매우 빨라야 한다고 생각했다.

위에서 언급한 조건을 모두 만족하는 자료구조는 `스택`이라고 생각했기 때문에 `스택`을 이용하여 풀이하였다.

그럼 스택에 어떤 데이터를 담을지 고민해보자.

**스택에 담을 데이터**는 `기준 원소의 인덱스`이다.

인덱스를 스택에 담으면 추후에 답을 할당할 배열의 인덱스로 넣어 반복문으로 손쉽게 출력할 수 있기 때문이다.

스택이 비어있지 않고, 스택에 가장 최근에 삽입한 원소`(기준 원소의 인덱스)`가 오른쪽의 원소`(for문으로 도는 요소)`보다 작은 경우,
`Answer[스택 꼭대기 데이터(인덱스)]`에 for문으로 돌고 있는 요소를 담는다.

`Answer`배열은 `-1`로 미리 초기화해두고,
**while**에서 기준 원소보다 큰 원소가 오른쪽에 없는 경우에는 그냥 건너뛰도록 코드를 작성하였다.

올해 상반기에 풀었던 문제인데, 또 오랫동안 헤매다가 풀었기 때문에 이번에는 까먹지 않도록 글로 풀어서 써보았다... ㅠ

### 풀이

<script src="https://gist.github.com/eotkd4791/ccef5f3dbbccb1d89c5be545d9318802.js"></script>
